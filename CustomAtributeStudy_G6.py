import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.base import BaseEstimator, TransformerMixin


#####################################################################################################################################################
# Creación de función para obtener detalle de nulos de un dataset o un atributo de este
"""Formas de invocar esta función:
AnalisisNulos(df=dataframe,column=dataframe.columns[indice])
"""
def AnalisisNulos(df,column:str=None):    
    if not column:
        for col in df.columns:
            n_nulos=df[col].isna().sum()
            p_nulos =(n_nulos/len(df)*100).round(2)
            print (f"El atributo '{col}' tiene {n_nulos} valores nulos ({p_nulos}%)")
    else:
        print (f"El atributo '{column}' tiene {df[column].isna().sum()} valores nulos ({((df[column].isna().sum())/len(df)*100).round(2)}%)")

    return
#####################################################################################################################################################
#####################################################################################################################################################
# creamos función para hacer la conversion logarítmica del atributo a estudiar
"""Formas de invocar esta función:
TransfLog(df=dataframe,atributo=dataframe.columns[indice])
"""
def TransfLog(df, atributo:str):
    atr_name=atributo+'_LOG'
    df[atr_name]=df[atributo].apply(np.log1p)

    return df, atr_name
#####################################################################################################################################################
#####################################################################################################################################################
#creamos función para realizar 4 plots que nos proporcionen información sobre el atributo numérico a estudiar.
"""Formas de invocar esta función:
PlotsNumericos(df=dataframe,atributo=dataframe.columns[indice])
"""

def PlotsNumericos(df, atributo:str, tar):
    fig =plt.figure(figsize=(20,10))
    ax1,ax2=fig.subplots(2,2)
    sns.boxplot(ax=ax1[0], data=df, x=tar, hue=tar, y=atributo);
    sns.violinplot(ax=ax1[1], data=df, x=tar, hue=tar, y=atributo);
    sns.histplot(ax=ax2[0], data=df, x=atributo, hue=tar );
    sns.boxenplot(ax=ax2[1], data=df, x=tar,hue=tar, y=atributo);
    sns.color_palette("Paired")
    plt.show()

    return
#####################################################################################################################################################
#####################################################################################################################################################
#creamos función para realizar 4 plots que nos proporcionen información sobre el atributo Categórico a estudiar.
"""Formas de invocar esta función:
PlotsCategoricos(df=dataframe,atributo=dataframe.columns[indice])
"""

def PlotsCategoricos(df, atributo:str, tar): 
    fig =plt.figure(figsize=(20,10))
    ax1,ax2=fig.subplots(2,1)
    sns.countplot(ax=ax1, data=df, x=atributo, hue=tar);
    sns.histplot(ax=ax2, data=df, x=atributo, hue=tar,stat='percent',element='step');
    plt.show()

    return
#####################################################################################################################################################
#####################################################################################################################################################
# Creación de función para análisis directo de variables numericas.
"""
Formas de invocar esta función:
AnalisisNumericas(df=dataframe,atributo=dataframe.columns[indice],log=1/0)

Reutilizamos las sigueitnes funciones:
    >> AnalisiNulos: Nos da información sobre los nulos del atributo a estudiar (# nulos y % nulos)
    >> TransfLog: Si se indica como parametro (1/True), convierte a LOG el atributo a estudiar
    >> PlotsNumericos: Crea 4 plots para el estudio del atributo indicado.
"""
def AnalisisNumericas(df, atributo:str, tar, log:bool=False):
    print('Atributo Numérico')
    if log:
        df,atributo=TransfLog(df,atributo)
        
    AnalisisNulos(df,atributo)
    print('\nDescripción estadístiica:', df[atributo].describe(),sep='\n')
    print(f"\nEl atributo tiene {df[atributo].nunique()} valores únicos",sep='\n' )
    print('\nTOP 10 porcentaje de valores únicos:',(df[atributo].value_counts(dropna=False,normalize=True)*100).head(10),sep='\n')
    PlotsNumericos(df,atributo,tar)
    
    return 

# Creación de función para estudio estadísitco de variables categoricass.
"""Formas de invocar esta función:
EstudioCategoricas(df=dataframe,atributo=dataframe.columns[indice])
"""
#####################################################################################################################################################
#####################################################################################################################################################
def EstudioCategoricas(df, atributo:str, tar):
    equipos_infectados = df.groupby(atributo, dropna = False).agg(
        Equipos = (tar, len),
        Infectados = (tar, 'sum'),
        Proporcion_Infectados = (tar, 'mean')
    ).sort_values(by='Equipos', ascending=False)

    equipos_infectados['Proporcion_Equipos'] = round(equipos_infectados['Equipos'] / equipos_infectados['Equipos'].sum()*100,2)
    equipos_infectados['Proporcion_Infectados'] = round(equipos_infectados['Proporcion_Infectados']*100, 2)
    equipos_infectados = equipos_infectados[['Equipos', 'Proporcion_Equipos', 'Infectados', 'Proporcion_Infectados']]

    return (equipos_infectados)
#####################################################################################################################################################
#####################################################################################################################################################
# Creación de función para análisis directo de variables categoricas.
"""
Formas de invocar esta función:
AnalisisCategoricas(df=dataframe,atributo=dataframe.columns[indice])

Reutilizamos las sigueitnes funciones:
    >> AnalisiNulos: Nos da información sobre los nulos del atributo a estudiar (# nulos y % nulos)
    >> PlotsCategoricos: Crea 4 plots para el estudio del atributo indicado.
    >> EstudioCategoricas: Crea un dataframe mostrando la distribución de valores únicos del atributo
"""
def AnalisisCategoricas(df, atributo:str,tar):
    print('Atributo Categórico')
    AnalisisNulos(df, atributo)
    print('\nDescripción estadístiica:', df[atributo].describe(),sep='\n\n')
    PlotsCategoricos(df,atributo,tar)

    return (EstudioCategoricas(df,atributo, tar))
#####################################################################################################################################################
#####################################################################################################################################################
# Creación de función para análisis directo de variables categoricas.
# La función discrimina si el atributo a estudiar en numérico o categorico y 
# muestra una información u otra en consecuencia.
"""
Formas de invocar esta función:
AnalisisAtributo(df=dataframe,atributo=dataframe.columns[indice], log=1/0)

Reutilizamos las sigueitnes funciones:
    >> AnalisisCategoricas: Estudio completo de variables categóricas
    >> AnalisisNumericas: Estudio completo de variables numéricas
    
"""
def AnalisisAtributo(df,atributo:str,tar,log=False):
    if df[atributo].dtype.kind=='O':
        return(AnalisisCategoricas(df,atributo,tar))
    else:
        return(AnalisisNumericas(df,atributo,tar,log))
    
#####################################################################################################################################################
#####################################################################################################################################################
# Creación de dataframe para representar los atributos finales para el modelo

def crearDataframePrep(df):
    df_atributos = pd.DataFrame(
    {
        'Atributo': df.columns.tolist(),
        'Tipo': [df[x].dtype for x in df.columns.tolist()],
        }
    )

    return df_atributos

#####################################################################################################################################################
#####################################################################################################################################################
# Se añaden las acciones que corresponden a cada atributo en el dataframe creado con la función anterior
# Según las conclusiones del EDA

def addPrepActions(df, impute_mode_cols, impute_m1_cols, impute_0_cols, impute_unk_cols, group_min_cols, group_top_cols, version_cols, ohe_cols):
    for i, row in df.iterrows():
    
    # Imputar
        if i in impute_mode_cols:
            df.loc[i, 'Imputar'] = 'moda'
        elif i in impute_m1_cols:
            df.loc[i, 'Imputar'] = 'constant_m1'
        elif i in impute_0_cols:
            df.loc[i, 'Imputar'] = 'constant_0'
        elif i in impute_unk_cols:
            df.loc[i, 'Imputar'] = 'unknown'
        else:
            df.loc[i, 'Imputar'] = '-'

    # Agrupar
        if i in group_min_cols:
            df.loc[i, 'Agrupar'] = 'minoritarios'
            df.loc[i, 'Top'] = '-'
            df.loc[i, 'TopRemainder'] = '-'
        elif i in group_top_cols['indice']:
            df.loc[i, 'Agrupar'] = 'top'
            pos = group_top_cols['indice'].index(i)
            df.loc[i, 'Top'] = group_top_cols['topN'][pos]
            df.loc[i, 'TopRemainder'] = group_top_cols['topRemainder'][pos]
        else:
            df.loc[i, 'Agrupar'] = '-'
            df.loc[i, 'Top'] = '-'
            df.loc[i, 'TopRemainder'] = '-'

    # Version
        if i in version_cols:
            df.loc[i, 'Formato'] = 'version'
        else:
            df.loc[i, 'Formato'] = '-'

    # Encode
        if i in ohe_cols:
            df.loc[i, 'Encode'] = 'OHE'
        elif i in version_cols:
            df.loc[i, 'Encode'] = 'Numérico'
        else:
            df.loc[i, 'Encode'] = '-'

    return df

#####################################################################################################################################################
#####################################################################################################################################################
# Clase Transformer personalizado para realizar acciones de preprocessing sobre los atributos

class DataPreparationTransformer(BaseEstimator, TransformerMixin):
    def __init__(self, acciones_col, lista_col):
        self.acciones_col = acciones_col
        self.lista_col = lista_col

    def fit(self, X, y=None):
        self.columns_ = X.columns
        return self

    def transform(self, X):
        df = X.copy()
        
        # Se reestablece el nombre y orden original de las columnas
        # debido a las modificaciones que produce el Column Transformer de la imputación de nulos
        df.columns = df.columns.str.split('__').str[1]
        df = df[self.lista_col]

        for col_dict in self.acciones_col:
          for accion, valor in col_dict.items():
            if accion in ['Atributo', 'Tipo', 'Encode', 'ColumnasGeneradas']:
              continue

            if accion == 'Formato':
              if valor == 'version':
                df = self.formatoVersion(df, col_dict['Atributo'])
            if accion == 'Agrupar':
              if valor == 'top':
                df = self.agruparTop(df, col_dict['Atributo'], col_dict['Top'], col_dict['TopRemainder'])
              elif valor == 'minoritarios':
                df = self.setOthers(df, col_dict['Atributo'], 0.01)

        return df

    def formatoVersion(self, df, atributo):
        if atributo == 'EngineVersion':
          df['EngineVersion'] = df['EngineVersion'].apply(lambda x: int(x.split('.')[0])*1e7 + int(x.split('.')[1]) * 1e6 + int(x.split('.')[2]) * 10 + int(x.split('.')[3]))
        elif atributo == 'AppVersion':
          df['AppVersion'] = df['AppVersion'].apply(lambda x: int(x.split('.')[1]) * 1e10 + int(x.split('.')[2]) * 1e5 + int(x.split('.')[3]))
        elif atributo == 'AvSigVersion':
          df['AvSigVersion'] = df['AvSigVersion'].apply(lambda x: int(x.split('.')[0]) * 1e8 + int(x.split('.')[1]) * 1e5 + int(x.split('.')[2]) * 1e1 + int(x.split('.')[3]))
        elif atributo == 'OsVer':
          df['OsVer'] = df['OsVer'].apply(lambda x: int(x.split('.')[0])*1e9 + int(x.split('.')[1]) * 1e6 + int(x.split('.')[2]) * 1e3 + int(x.split('.')[3]))

        return df

    def agruparTop(self, df, atributo, n, remainder):
        topN = df[atributo].value_counts().index.tolist()[:n]
        df[atributo] = df[atributo].apply(lambda x: x if x in topN else remainder)

        return df

    def setOthers(self, df, atributo, pct):
        top_category_list = list(map(str, df[atributo].value_counts()[df[atributo].value_counts(normalize=True)>pct].index.to_list()))
        df[atributo] = df[atributo].astype(str)
        top_category_list.append('Others')
        df[atributo] = pd.Categorical(df[atributo], categories = top_category_list)
        df[atributo] = df[atributo].fillna('Others')

        return df

